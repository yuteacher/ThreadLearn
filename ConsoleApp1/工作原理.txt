5.1 工作原理
	当程序运行时运行了两个异步操作。其中一个是标准的TPL模式的代码，第二个使用了C#的新特性 async 和await。AsynchronyWithTPL方法启动了一个任务，运行两秒后返回关于工作线程信息的字符串。
然后我们定义了一个后续操作，用于在异步操作完成后打印出该操作结果，还有另一个后续操作，用于万一有错误发生时打印出异常的细节。最终，返回了一个代表其中一个后续操作任务的任务，并等待其
在 Main 函数中完成。在 AsynchronyWithAwait方法中，我们对任务使用await 并得到了相同的结果。这和编写通常的同步代码的风格一样，即我们获取任务的结果，打印出结果，如果任务完成时带有错误
则捕获异常。关键不同的是这实际上是一个异步程序。使用await后，C#立即创建了一个任务，其有一个后续操作任务，包含了await操作符后面的所有剩余代码。这个新任务也处理了异常传播。然后，将该
任务返回到主方法中并等待其完成。请注意根据底层异步操作的性质和当前异步的上下文，执行异步代码的具体方式可能会不同。稍后在本章中会解释这一点。因此可以看到程序的第一部分和第二部分在概
念上是等同的，但是在第二部分中C#编译器隐式地处理了异步代码。事实上，第二部分比第一部分更复杂，接下来我们将讲述细节。
	请记住在 Windows GUI或 ASP.NET之类的环境中不推荐使用 Task.Wait 和Task,Resul方法。如果程序员不是百分百地清楚代码在做什么，很可能会导致死锁。在第4章的4.10节中，在 WPF 应用程序中
使用 Task,Result 时已经演示了该一点。请取消对 GetInfoAsync方法的throw new Exception代码行的注释来测试异常处理是否工作。
	