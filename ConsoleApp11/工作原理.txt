8.7工作原理
	本节展示了如何将不同类型的异步操作转换为(hervable类。步骤5的第一个代码片段使用了Obscrvable.snrt方法，其与TPL中的Task.Run方法很相似。它启动了异步操作并返回一个字符串结果，然后退出。
	我强烈建议使用任务并行库来执行异步搡作。虽然Reactive Extensions也支持该功能．但是为了避免使用不当，当讲单独的异步搡作时最好使用任务，而只有需要与事件序列工作时才用Rx.另一个建议是将单独的异步搡作转換为任
务，只有在需要时才把任务转换为observable类
	然后，我们同样通过简单调用ToObservable扩展方法把任务转换为Observable方法。步驟5的接下来的代码片段是关于将异步编程模块模式转换为(hervable类。通常你可能将APM转换为任务，再把任务转换为Obsewab1e类。然而其实
可以直接转换，该例子演示了如何运行一个异步委托并将其封装到Observable操作中。
	步5的下一段代码片段展示了我们可以对Observable操作使用awaita我们无法给一个人口方法（例如Main)使用async修饰符，所以引人了一个单独的方法来运行一个任务，并等待该任务在Main方法中完成执行。
	步骤5的最后一部分代码片段与之前是一样的，但是这里我们把基于事件的异步模式直接转换为Observable我们创建了一个计时器并消费该计时器事件5秒钟然后对该计时器调用dispose方法以清除资源。