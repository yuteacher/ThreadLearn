4.10.3 工作原理
	本例中引人了很多新鲜的东西。首先，创建了一个 WPF 应用程序，而不是一个命令行程序。这是很有必要的，因为我们需要一个拥有消息循环的用户界面线程来演示异步运行任
务的不同情形。TaskScheduler是一个非常重要的抽象。该组件实际上负责如何执行任务。默认的任务调度程序将任务放置到线程池的工作线程中。这是非常常见的场景，所以TPL将其
作为默认选项并不用奇怪。我们已经知道了如何同步运行任务，以及如何将任务附加到父任务上从而一起运行。现在让我们看看使用任务的其他方式。当程序启动时，创建了一个包含
三个按钮的窗口。第一个按钮调用了一个同步任务的执行。该代码被放置在 ButtonSyncClick方法中。当任务运行时，我们甚至无法移动应用程序窗口。当用户界面线程忙于运行任务
时，整个用户界面被完全冻结，在任务完成前无法响应任何消息循环。对于GUI窗口程序来说这是一个相当不好的实践，我们需要找到一个方式来解决该问题。第二个问题是我们尝试从
其他线程访问U控制器。图形用户界面控制器从没有被设计为可被多线程使用，并且为了避免可能的错误，不允许从创建的线程之外的线程中访问UI组件。当我们尝试这样做时，得到了
一个异常，该异常信息5秒后打印到了主窗口中。为了解决第一个问题，我们尝试异步运行任务。第二个按钮就是这样做的。该代码被放置在ButtonAsync_Click方法中。当使用调试模
式运行该任务时，将会看到该任务被放置在线程池中，最后将得到同样的异常。然而，当任务运行时用户界面一直保持响应。这是好事，但是我们仍需要除掉异常。其实我们已经解决
了该问题。给TaskScheduler.FromCurrentSynchronizationContext 选项提供一个后续操作用于输出错误信息。如果不这样做，我们将无法看到错误信息，因为可能会得到在任务中产
生的相同异常。该选项驱使TPL基础设施给UI线程的后续操作中放入代码，并借助UI线程消息循环来异步运行该代码。这解决了从其他线程访问U控制器并仍保持 UI处于响应状态的问题。
为了检查是否真的是这样，可以按下最后一个按钮来运行ButtonAsyncOKClick方法中的代码。与其余例子不同之处在于我们将U线程任务调度程序提供给了该任务。你将看到任务以异步
的方式运行在U线程中。U依然保持响应。甚至尽管等待光标处于激活状态你仍可以按下另一个按钮。然而使用UI线程运行任务有一些技巧。如果回到同步任务代码，取消对使用U1线程任
务调度程序获取结果的代码行的注释，我们将永远得不到任何结果。这是一个经典的死锁情况:我们在UI线程队列中调度了一个操作，线程等待该操作完成，但当等待时，它又无法运行
该操作，这将永不会结束(甚至永不会开始)。如果在任务中调用Wait方法也会发生死锁。为了避免死锁，绝对不要通过任务调度程序在U线程中使用同步操作，请使用 ContinueWith或async/await 方法。