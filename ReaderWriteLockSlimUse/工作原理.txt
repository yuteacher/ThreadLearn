2.9.3 工作原理
	当主程序启动时，同时运行了三个线程来从字典中读取数据，还有另外两个线程向该字典中写人数据。我们使用ReaderWriterLockSlim 类来实现线程安全，该类专为这样的场景而设计。这里使用两种锁:读锁允许多线程读取数据，
写锁在被释放前会阻塞了其他线程的所有操作。获取读锁时还有一个有意思的场景，即从集合中读取数据时，根据当前数据而决定是否获取一个写锁并修改该集合。一旦得到写锁，会阻止阅读者读取数据，从而浪费大量的时间，因此
获取写锁后集合会处于阻塞状态。为了最小化阻塞浪费的时间，可以使用EnterUpgradeableReadLock和ExitUpgradeableReadLock方法。先获取读锁后读取数据。如果发现必须修改底层集合，只需使用EnterWriteLock方法升级锁，然后
快速执行一次写操作最后使用 ExitWriteLock释放写锁。
	在本例中，我们先生成一个随机数。然后获取读锁并检查该数是否存在于字典的键集合中。如果不存在，将读锁更新为写锁然后将该新键加人到字典中。始终使用tyr/fnaly 代码块来确保在捕获锁后一定会释放锁，这是一项好的实
践。所有的线程都被创建为后台线程。主线程在所有后台线程完成后会等待30秒。