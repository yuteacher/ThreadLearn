10.2.3 工作原理
	第一个例子展示了在多个访问线程中为什么使用 UnsafeState 对象是不安全的。可以看到构造方法被调用了多次，并且不同的线程中值是不同的，显而易见这是错误的。为了修复该问题，我们可以
在读取值时使用锁，如果值还未初始化，则先创建。这虽然可行，但是对每个读操作都使用锁非常低效。为了避免每次都使用锁，有一个传统的方式叫做双重锁定(double-checked locking)模式。第一
次检查该值时，如果它不是 nul，我们避免了没有必要的锁来使用共享对象。然而，如果它还未被构造，我们使用锁并再一次检查该值，因为它可能在第一次检查和锁定操作之间被初始化。如果仍未被
初始化，那么我们计算该值。我们可以看到第二个示例使用了该方式。对构造方法只有一次调用，并且第一个调用的线程定义了该共享对象状态。
	请记住如果惰性求值的对象实现是线程安全的，并不自动说明它的所有属性也是线程安全的。
	例如，如果你给ValueToAccess对象添加一个int公共属性，它则不是线程安全的。你仍需要使用互锁结构(interlockedconstruct)或锁来保证线程安全。
	该模式很常见，这也是为什么在基础类库中有一些类来方便我们使用。首先，我们可以使用 LazyInitializer.EnsureInitialized方法，其内部实现了双重锁定模式。然而，最舒服的选项是使用
Lazy<T>类。它可以让我们立即拥有可用的线程安全并且惰性求值的共享状态对象。接下来的两个例子展示了它们与第二个例子几乎相同，程序行为也一致。唯一不同是由于 LazyInitializer 是一个静
态类，因此我们无需创建一个类的实例，而 Lazy<T>中例子则需要，因此前者的性能在某些场景中更好。
	最后一个选择是如果我们不关心构造方法，则完全可以避免使用锁。如果对象是线程安全的并且没有副作用和严重的性能影响，我们可以只使用第一个构造值运行多次。最后一个例子展示了该行为，
我们可以使用另一个 LazyInitializer. Ensurelnitialized方法重载达到目的。