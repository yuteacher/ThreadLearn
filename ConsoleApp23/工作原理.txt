5.10工作原理
	这里我们重复了5．9节的技巧，但是这次借助于动态表达式，可以使用NuGet来实现该目标。NuGet是一个包含了很多有用的库的包管理器这次我们将使用一个库来动态地创建封装对象，实现我们需要的接口。
	首先我们创建了ExpandoObject类型的两个实例，并把它们分配给动态的局部变量。这些变量将成为awaitable和awaiter对象。由于一个awaitable对象只需要拥有GetAwaiter方法，提供该方法没有问题使用dynamc关键
字组合ExndoOjbect允许我们自定义该对象并通过分配相应的值来添加属性和方法。事实上它是一个字典类型的集合，键类型是string，值类型是object如果你很熟悉Javascript编程语言，你可能会注意到它与JavaScnpt对象很
相似
	由于dynamic关键字允许我们跳过C#的编译时检查。ExpandObject是以这样的方式编写的：当你给属性分配值时，ExpandObject创建了一个字典条目，键是属性名，值是赋予的任何值。当尝试获取属性值时，会在字典中查
找并提供存储在相应的字典条目中的值如果该值是Ac№n或Func类型，我们实际上存储了一个委托，它可以当做方法使用。因此，ExpandoObJect与dynamrc类型的组合允许我们创建一个对象并动态地赋予其属性和方法.
	现在我们需要构造自定义的和awaitable对象。先从awaner开始。首先提供一个名为Mege的属性并赋予初始值，然后使用Func<string>类型定义了GetResuIt方法，并分配一个lambda表达式，该表达式返回Message属性值。
接下来实现IsCompleted属性。如果其值为true，则跳过剩下的工作并处理存储在result局部变量中的awaitable对象。我们只需要添加一个方法用于返回该dynarmc对象并从该对象返回awaiter对象。我们可以使用result作为await表达式。
然而，它将会同步运行。
	主要的挑战是在动态对象中实现异步处理。C#语言规格说明规定awaiter必须实现INot1fyCompleuon或ICriticalNot1fyCompleuon接口，但是ExpandoObject却没有。甚至当我们动态地实现Oncompleted方法并添加到awaiter
对象时，这仍然行不通，因为该对象没有实现上面提到的任何一个接口。
	为了解决该问题，我们使用了NuGet提供的lmpromptulnterface库。它允许我们使用Impromptu.ActLike方法来动态地创建代理对象，该对象将实现任何需要的接口。如果我们尝试创建一个实现了INotifyCompletion接口的代
理，仍然行不通，因为该代理对象不再是动态的，并且该接口只有OnCompIeted方法，但没有属性或GetResult方法。作为最后的解决办法，我们定义了一个泛型接口，IAwaiter<T>.它实现了INot1fyCompletion并添加了所有需要
的属性和方法。现在，我们使用它生成代理并修改result对象来从Gewaiter方法返回一个代理，而不是返回对象。现在程序可以工作了，我们构造了一个在运行时完全动态的awaitable对象.