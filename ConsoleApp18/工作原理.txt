5.8.3 工作原理
	当程序启动时，我们通过调用AsyncTask和AsyncVoid这两个方法启动了两个异步作。第一个方法返回一个Task对象，而另一个由于被声明为async void所以没有返回值。由于它们都是异步的所以都会立即返回。
但是第一个方法通过返回的任务状态或对其调用Wait方法从而很容易实现监控。等待第二个方法完成的唯一方式是确切地等待多长时间因为我们没有声明任何对象可以监控该异步操作的状态。当然可以使用某种共
享的状态变量，将其设置到 async void方法中，并从调用方法中检查其值，但返回一个Task对象的方式更好些。
	最危险的部分是异常处理。使用asyncvoid方法，异常处理方法将被放置到当前的同步上下文中，在本例中即线程池中。线程池中未被处理的异常会终结整个进程。使用AppDomain.UnhandledException事件可以
拦截未被处理的异常，但不能从拦截的地方恢复进程。为了重现该场景，可以取消Main方法中对try/catch代码块的注释，然后运行程序。
	关于使用 async void lambda表达式的另一个事实是:它们与 Action 类型是兼容的，而Action 类型在标准.NET Framework类库中的使用非常广泛。在 lambda表达式中很容易忘记对异常的处理，这将再次导致
程序崩溃。可以取消在Main方法中第二个被注释的代码块的注释来重现该场景。
	强烈建议只在UI事件处理器中使用async void方法。在其他所有的情况下，请使用返回 Task 的方法。