6.3 工作原理
	先说第一个场景，这里我们使用了BlockingCollection类，它带来了很多优势。首先我们能够改变任务存储在阻塞集合中的方式。默认情况下它使用的是ConcurrentQueue 容器但是我们能够使用任何实现了 IProducerConsumerCollection
泛型接口的集合。为了演示该点我们运行了该程序两次，第二次时使用ConcurrentStack作为底层集合。工作者通过对阻塞集合迭代调用GetConsumingEnumerable方法来获取工作项。如果在该集合中没有任何元素，迭代器会阻
塞工作线程直到有元素被放置到集合中。当生产者调用集合的 CommpleteAdding 时该迭代周期会结束。这标志着工作完成了。这里很容易犯一个错误，即对BlockingCollection进行迭代，因为它自身实现了numerable接口。不
要忘记使用GetConsumingEnumerable，否则你选代的只是集合的“快照”，这并不是期望的程序行为。工作量生产者将任务插人到 BlockingCollection然后调用CompleteAdding方法，这会使所有工作者完成工作。现在在程序
输出中我们看到两个结果序列，演示了并发队列和堆栈集合的不同之处。